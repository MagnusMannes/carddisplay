<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-store" />
  <title>Live Counts</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 16px; line-height: 1.4; }
    header { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 12px; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    label { display: inline-flex; gap: 6px; align-items: center; }
    button, select { font: inherit; padding: 6px 10px; }
    #status { font-size: .95rem; opacity: .85; }
    .warn { color: #b21; font-weight: 600; }

    /* Bars */
    .rows { display: grid; gap: 12px; max-width: 900px; }
    .row { display: grid; grid-template-columns: 160px 1fr; gap: 12px; align-items: center; }
    .name { font-weight: 600; }
    .barWrap {
      position: relative; height: 32px; border-radius: 999px; overflow: hidden;
      background: color-mix(in oklab, Canvas 92%, CanvasText 8%);
    }
    @media (prefers-color-scheme: dark) {
      .barWrap { background: color-mix(in oklab, Canvas 80%, CanvasText 20%); }
    }
    .bar { height: 100%; width: 0; transition: width .25s ease; }
    .bar.schl { background: #3b82f6; }
    .bar.baker { background: #10b981; }
    .count {
      position: absolute; right: 10px; top: 50%; transform: translateY(-50%);
      font-weight: 700; text-shadow: 0 1px 2px rgb(0 0 0 / .2);
      color: white;
    }

    footer { margin-top: 14px; font-size: .9rem; opacity: .8; }
  </style>
</head>
<body>
  <header>
    <div class="controls">
      <label>Poll every
        <select id="intervalSelect">
          <option value="15000">15 sec</option>
          <option value="30000">30 sec</option>
          <option value="60000" selected>60 sec</option>
          <option value="120000">2 min</option>
          <option value="300000">5 min</option>
        </select>
      </label>
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <button id="clearBtn">Clear</button>
      <button id="downloadBtn">Download CSV</button>
    </div>
    <div id="status" aria-live="polite">Idle.</div>
  </header>

  <main class="rows" id="rows">
    <div class="row">
      <div class="name">Schlumberger</div>
      <div class="barWrap">
        <div class="bar schl" id="bar-schl"></div>
        <span class="count" id="count-schl">0</span>
      </div>
    </div>
    <div class="row">
      <div class="name">Baker Hughes</div>
      <div class="barWrap">
        <div class="bar baker" id="bar-baker"></div>
        <span class="count" id="count-baker">0</span>
      </div>
    </div>
  </main>

  <footer>
    Source: <code>https://dabsafecard.azurewebsites.net/report?date=today</code>.
    If you see a fetch error, it’s likely CORS — set <code>proxyUrl</code> below to a pass‑through you control.
  </footer>

<script>
(() => {
  // ====== Configuration ======
  const baseUrl = "https://dabsafecard.azurewebsites.net/report?date=today";

  // If CORS blocks you, put your proxy endpoint here
  const proxyUrl = ""; // e.g. "https://your-worker.example.workers.dev"

  const needles = {
    schlumberger: "<td>Schlumberger</td>",
    baker: "<td>Baker Hughes</td>"
  };

  // Fixed-scale behavior:
  // - if max count <= FILL_AT, use 0–FILL_AT (50 fills the bar)
  // - if max count  > FILL_AT, use 0–OVERFLOW_MAX (switches to 0–100)
  const FILL_AT = 50;
  const OVERFLOW_MAX = 100;

  // ====== DOM ======
  const statusEl = document.getElementById("status");
  const startBtn = document.getElementById("startBtn");
  const stopBtn  = document.getElementById("stopBtn");
  const clearBtn = document.getElementById("clearBtn");
  const dlBtn    = document.getElementById("downloadBtn");
  const intervalSelect = document.getElementById("intervalSelect");

  const barSchl   = document.getElementById("bar-schl");
  const barBaker  = document.getElementById("bar-baker");
  const countSchl = document.getElementById("count-schl");
  const countBaker= document.getElementById("count-baker");

  // ====== State ======
  let totals = { schl: 0, baker: 0 };
  let history = []; // {time, schl_total, baker_total, schl_delta, baker_delta}
  let timer = null;

  // ====== Utilities ======
  function setStatus(text, warn=false) {
    statusEl.textContent = text;
    statusEl.className = warn ? "warn" : "";
  }

  function countOccurrences(haystack, needle) {
    if (!needle || !haystack) return 0;
    let count = 0, pos = 0;
    while ((pos = haystack.indexOf(needle, pos)) !== -1) {
      count++; pos += needle.length;
    }
    return count;
  }

  function buildUrl() {
    const cacheBuster = `_=${Date.now()}`;
    const urlWithBuster = baseUrl + (baseUrl.includes("?") ? "&" : "?") + cacheBuster;
    if (proxyUrl) return proxyUrl.replace(/\/$/, "") + "/" + encodeURIComponent(urlWithBuster);
    return urlWithBuster;
  }

  function formatTime(d = new Date()) {
    return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
  }

  function withTimeout(ms, fn) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), ms);
    return fn(ctrl).finally(() => clearTimeout(t));
  }

  // === NEW: fixed-scale + snapshot updates ===
  function updateBars() {
    const maxCount = Math.max(totals.schl, totals.baker);
    const scaleMax = maxCount <= FILL_AT ? FILL_AT : OVERFLOW_MAX;

    const schlPct  = Math.min(100, (totals.schl  / scaleMax) * 100);
    const bakerPct = Math.min(100, (totals.baker / scaleMax) * 100);

    barSchl.style.width  = schlPct + "%";
    barBaker.style.width = bakerPct + "%";

    countSchl.textContent  = String(totals.schl);
    countBaker.textContent = String(totals.baker);
  }

  function clearAll() {
    totals = { schl: 0, baker: 0 };
    history = [];
    updateBars();
    setStatus("Data cleared.");
  }

  function toCSV() {
    const rows = [["time","schlumberger_total","baker_hughes_total","schlumberger_added","baker_hughes_added"]];
    for (const r of history) {
      rows.push([r.time, r.schl_total, r.baker_total, r.schl_delta, r.baker_delta]);
    }
    return rows.map(r => r.join(",")).join("\n");
  }

  // ====== Polling ======
  async function sampleOnce() {
    const started = new Date();
    const url = buildUrl();
    try {
      setStatus("Fetching…");
      const res = await withTimeout(15000, (ctrl) =>
        fetch(url, { method: "GET", cache: "no-store", redirect: "follow", signal: ctrl.signal })
      );
      if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);

      const text = await res.text();

      // Count what's on the page RIGHT NOW (snapshot), not cumulative adds
      const sNow = countOccurrences(text, needles.schlumberger);
      const bNow = countOccurrences(text, needles.baker);

      // Compute deltas vs. previous totals for history/status only
      const prev = { ...totals };
      const sDelta = sNow - prev.schl;
      const bDelta = bNow - prev.baker;

      // === KEY CHANGE: replace totals with the latest snapshot ===
      totals.schl  = sNow;
      totals.baker = bNow;

      updateBars();

      history.push({
        time: formatTime(started),
        schl_total: totals.schl,
        baker_total: totals.baker,
        schl_delta: sDelta,
        baker_delta: bDelta
      });

      setStatus(`Last update ${formatTime()} — Δ ${sDelta >= 0 ? "+" + sDelta : sDelta} Schlumberger, ${bDelta >= 0 ? "+" + bDelta : bDelta} Baker Hughes. Totals: ${totals.schl} / ${totals.baker}.`);
    } catch (err) {
      setStatus(`Fetch failed: ${err?.message || err}. If this is a CORS error, set a proxyUrl or enable CORS on the source.`, true);
      console.error(err);
    }
  }

  function startPolling() {
    if (timer) return;
    sampleOnce(); // immediate
    const intervalMs = parseInt(intervalSelect.value, 10) || 60000;
    timer = setInterval(sampleOnce, intervalMs);
    startBtn.disabled = true;
    stopBtn.disabled = false;
    setStatus("Polling started.");
  }

  function stopPolling() {
    if (!timer) return;
    clearInterval(timer);
    timer = null;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    setStatus("Polling stopped.");
  }

  // ====== Events ======
  startBtn.addEventListener("click", startPolling);
  stopBtn.addEventListener("click", stopPolling);
  clearBtn.addEventListener("click", clearAll);
  dlBtn.addEventListener("click", () => {
    const csv = toCSV();
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "counts.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
  intervalSelect.addEventListener("change", () => { if (timer) { stopPolling(); startPolling(); } });

  // Auto-start so you see it working right away
  startPolling();
})();
</script>
</body>
</html>
